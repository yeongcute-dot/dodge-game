<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>미니 닷지 게임</title>
  <style>
    body{
      margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", sans-serif;
      background:#0b1020; color:#e9eefc; display:flex; justify-content:center; align-items:center; height:100vh;
    }
    .wrap{ width:min(900px, 96vw); }
    .top{
      display:flex; gap:12px; align-items:center; justify-content:space-between; margin-bottom:10px; flex-wrap:wrap;
    }
    .card{
      background:rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.12);
      border-radius:14px; padding:10px 12px; display:flex; gap:14px; align-items:center;
      box-shadow: 0 10px 30px rgba(0,0,0,0.25);
    }
    button{
      cursor:pointer; border:none; border-radius:12px; padding:10px 14px; font-weight:700;
      background:#4f7cff; color:white;
    }
    button:active{ transform:translateY(1px); }
    .hint{ opacity:.9; font-size:14px; line-height:1.4; }
    canvas{
      width:100%; height:auto; background:rgba(255,255,255,0.04);
      border:1px solid rgba(255,255,255,0.12); border-radius:18px;
      box-shadow: 0 12px 40px rgba(0,0,0,0.35);
      touch-action:none;
    }
    .small{ font-size:13px; opacity:.8; }
    .kbd{
      display:inline-block; padding:2px 8px; border-radius:999px;
      border:1px solid rgba(255,255,255,0.18); background:rgba(0,0,0,0.2);
      font-weight:700;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="top">
      <div class="card">
        <div><b>점수:</b> <span id="score">0</span></div>
        <div><b>최고:</b> <span id="best">0</span></div>
        <div class="small">난이도는 시간이 지날수록 ↑</div>
      </div>
      <div class="card">
        <button id="btnStart">시작 / 재시작</button>
        <div class="hint">
          이동: <span class="kbd">←</span> <span class="kbd">→</span> 또는 <span class="kbd">A</span> <span class="kbd">D</span><br/>
          모바일: 화면에서 플레이어를 <b>드래그</b>
        </div>
      </div>
    </div>

    <!-- 내부 해상도(논리) -->
    <canvas id="cv" width="900" height="520"></canvas>
  </div>

<script>
(() => {
  const canvas = document.getElementById("cv");
  const ctx = canvas.getContext("2d");
  const scoreEl = document.getElementById("score");
  const bestEl = document.getElementById("best");
  const btnStart = document.getElementById("btnStart");

  // 저장된 최고점수
  const BEST_KEY = "mini_dodge_best_v1";
  let best = Number(localStorage.getItem(BEST_KEY) || 0);
  bestEl.textContent = best;

  // 게임 상태
  let running = false;
  let lastT = 0;
  let t = 0;
  let score = 0;

  const W = canvas.width, H = canvas.height;

  const player = {
    x: W/2, y: H-60,
    r: 14,
    vx: 0,
    speed: 520
  };

  let hazards = [];
  let spawnTimer = 0;

  const keys = new Set();

  function reset() {
    running = true;
    lastT = 0;
    t = 0;
    score = 0;
    scoreEl.textContent = "0";
    player.x = W/2;
    player.vx = 0;
    hazards = [];
    spawnTimer = 0;
    requestAnimationFrame(loop);
  }

  function rand(min, max) { return Math.random()*(max-min)+min; }

  function spawnHazard() {
    // 시간이 지날수록 떨어지는 속도/크기/빈도 증가
    const level = 1 + t / 18;
    const r = rand(10, 26) * Math.min(1.25, 0.9 + level*0.06);
    const speed = rand(160, 320) * Math.min(2.0, 0.9 + level*0.08);
    hazards.push({
      x: rand(r, W - r),
      y: -r - 10,
      r,
      vy: speed,
      wobble: rand(0.5, 2.2),
      phase: rand(0, Math.PI*2),
    });
  }

  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

  function collideCircle(a, b) {
    const dx = a.x - b.x;
    const dy = a.y - b.y;
    const rr = a.r + b.r;
    return dx*dx + dy*dy <= rr*rr;
  }

  function gameOver() {
    running = false;
    best = Math.max(best, Math.floor(score));
    localStorage.setItem(BEST_KEY, best);
    bestEl.textContent = best;
    draw(true);
  }

  function draw(ended=false) {
    ctx.clearRect(0,0,W,H);

    // 배경 그라디언트 느낌
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0, "rgba(79,124,255,0.12)");
    g.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    // 바닥 라인
    ctx.strokeStyle = "rgba(255,255,255,0.15)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(20, H-40);
    ctx.lineTo(W-20, H-40);
    ctx.stroke();

    // 장애물
    for (const h of hazards) {
      ctx.beginPath();
      ctx.fillStyle = "rgba(255,130,130,0.85)";
      ctx.arc(h.x, h.y, h.r, 0, Math.PI*2);
      ctx.fill();

      ctx.beginPath();
      ctx.strokeStyle = "rgba(255,255,255,0.22)";
      ctx.arc(h.x - h.r*0.25, h.y - h.r*0.25, h.r*0.35, 0, Math.PI*2);
      ctx.stroke();
    }

    // 플레이어
    ctx.beginPath();
    ctx.fillStyle = "rgba(130,255,200,0.95)";
    ctx.arc(player.x, player.y, player.r, 0, Math.PI*2);
    ctx.fill();

    // UI 텍스트(캔버스 내부)
    ctx.fillStyle = "rgba(233,238,252,0.9)";
    ctx.font = "16px system-ui, sans-serif";
    ctx.fillText("오래 버티면 점수↑ / 장애물에 닿으면 게임 오버", 22, 28);

    if (!running && ended) {
      ctx.fillStyle = "rgba(0,0,0,0.55)";
      ctx.fillRect(0,0,W,H);

      ctx.fillStyle = "#e9eefc";
      ctx.font = "bold 44px system-ui, sans-serif";
      ctx.textAlign = "center";
      ctx.fillText("게임 오버!", W/2, H/2 - 20);

      ctx.font = "18px system-ui, sans-serif";
      ctx.fillText(`점수: ${Math.floor(score)}  |  최고: ${best}`, W/2, H/2 + 20);
      ctx.fillStyle = "rgba(233,238,252,0.9)";
      ctx.fillText("위의 '시작 / 재시작' 버튼을 눌러 다시 시작!", W/2, H/2 + 52);

      ctx.textAlign = "left";
    }
  }

  function update(dt) {
    t += dt;

    // 입력 처리
    let dir = 0;
    if (keys.has("ArrowLeft") || keys.has("KeyA")) dir -= 1;
    if (keys.has("ArrowRight") || keys.has("KeyD")) dir += 1;
    player.vx = dir * player.speed;

    player.x += player.vx * dt;
    player.x = clamp(player.x, player.r + 12, W - player.r - 12);

    // 스폰 주기 (시간 지나면 더 자주)
    const level = 1 + t / 18;
    const spawnEvery = Math.max(0.12, 0.62 - level*0.04); // 최소 0.12초
    spawnTimer += dt;
    while (spawnTimer >= spawnEvery) {
      spawnTimer -= spawnEvery;
      spawnHazard();
    }

    // 장애물 이동
    for (const h of hazards) {
      h.y += h.vy * dt;
      h.x += Math.sin(t*h.wobble + h.phase) * (18 + t*0.2) * dt; // 살짝 흔들림
      h.x = clamp(h.x, h.r, W - h.r);
    }

    // 화면 밖 제거
    hazards = hazards.filter(h => h.y < H + h.r + 30);

    // 점수(시간 기반)
    score += dt * (10 + level*2);
    scoreEl.textContent = String(Math.floor(score));

    // 충돌 체크
    for (const h of hazards) {
      if (collideCircle(player, h)) {
        gameOver();
        break;
      }
    }
  }

  function loop(ts) {
    if (!running) return;
    if (!lastT) lastT = ts;
    const dt = Math.min(0.033, (ts - lastT) / 1000); // 프레임 폭주 방지
    lastT = ts;

    update(dt);
    draw(false);
    requestAnimationFrame(loop);
  }

  // 키보드
  window.addEventListener("keydown", (e) => {
    if (["ArrowLeft","ArrowRight","KeyA","KeyD"].includes(e.code)) e.preventDefault();
    keys.add(e.code);
  }, { passive:false });

  window.addEventListener("keyup", (e) => keys.delete(e.code));

  // 터치/드래그(모바일)
  let dragging = false;
  function getCanvasX(clientX){
    const rect = canvas.getBoundingClientRect();
    const x = (clientX - rect.left) * (canvas.width / rect.width);
    return x;
  }
  canvas.addEventListener("pointerdown", (e) => {
    dragging = true;
    canvas.setPointerCapture(e.pointerId);
    player.x = clamp(getCanvasX(e.clientX), player.r+12, W-player.r-12);
  });
  canvas.addEventListener("pointermove", (e) => {
    if (!dragging) return;
    player.x = clamp(getCanvasX(e.clientX), player.r+12, W-player.r-12);
  });
  canvas.addEventListener("pointerup", () => dragging = false);
  canvas.addEventListener("pointercancel", () => dragging = false);

  btnStart.addEventListener("click", reset);

  // 시작 화면
  running = false;
  draw(true);
})();
</script>
</body>
</html>
